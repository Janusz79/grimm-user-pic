/*! postcss-smart-asset v0.7.4 by Sebastian Software <s.werner@sebastian-software.de> */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('core-js/modules/es6.regexp.search');
require('core-js/modules/es6.array.map');
require('core-js/modules/es6.array.is-array');
require('core-js/modules/es6.array.index-of');
require('core-js/modules/es6.regexp.replace');
var path = _interopDefault(require('path'));
var url = _interopDefault(require('url'));
require('core-js/modules/es6.array.find-index');
require('core-js/modules/es6.regexp.constructor');
require('core-js/modules/es6.array.filter');
var minimatch = _interopDefault(require('minimatch'));
require('core-js/modules/es6.array.find');
var fs = require('fs');
var fs__default = _interopDefault(fs);
var mime = _interopDefault(require('mime/lite'));
require('core-js/modules/es6.function.name');
var cpFile = _interopDefault(require('cp-file'));
var assetHash = require('asset-hash');
require('core-js/modules/es6.regexp.to-string');
require('core-js/modules/es6.date.to-string');
var pify = _interopDefault(require('pify'));
require('core-js/modules/es6.promise');
require('core-js/modules/es6.array.iterator');
require('core-js/modules/es6.string.iterator');
require('core-js/modules/es6.regexp.match');
require('core-js/modules/web.dom.iterable');
require('core-js/modules/es6.array.for-each');
var postcss = _interopDefault(require('postcss'));

var normalize = function normalize(assetUrl) {
  assetUrl = path.normalize(assetUrl);

  if (path.sep === "\\") {
    assetUrl = assetUrl.replace(/\\/g, "/");
  }

  if (assetUrl.charAt(0) !== "." && assetUrl.charAt(0) !== "/") {
    assetUrl = "./" + assetUrl;
  }

  return assetUrl;
};
var isUrlWithoutPathname = function isUrlWithoutPathname(assetUrl) {
  return assetUrl[0] === "#" || assetUrl.indexOf("%23") === 0 || assetUrl.indexOf("data:") === 0 || /^[a-z]+:\/\//.test(assetUrl);
};
var isUrlShouldBeIgnored = function isUrlShouldBeIgnored(assetUrl, options) {
  return isUrlWithoutPathname(assetUrl) || assetUrl[0] === "/" && !options.basePath;
};
var getAssetsPath = function getAssetsPath(baseDir, assetsPath, relative) {
  return path.resolve(baseDir, assetsPath || "", relative || "");
};
var getTargetDir = function getTargetDir(dir) {
  return dir.from !== dir.to ? dir.to : process.cwd();
};
var getPathDeclFile = function getPathDeclFile(decl) {
  return decl.source && decl.source.input && decl.source.input.file;
};
var getDirDeclFile = function getDirDeclFile(decl) {
  var filename = getPathDeclFile(decl);
  return filename ? path.dirname(filename) : process.cwd();
};
var getPathByBasePath = function getPathByBasePath(basePath, dirFrom, relPath) {
  if (relPath[0] === "/") {
    relPath = "." + relPath;
  }

  basePath = !Array.isArray(basePath) ? [basePath] : basePath;
  return basePath.map(function (pathItem) {
    return getAssetsPath(dirFrom, pathItem, relPath);
  });
};
var prepareAsset = function prepareAsset(assetUrl, dir, decl) {
  var parsedUrl = url.parse(assetUrl),
      pathname = !isUrlWithoutPathname(assetUrl) ? parsedUrl.pathname : null,
      absolutePath = pathname ? path.resolve(path.join(dir.file, pathname)) : getPathDeclFile(decl);
  return {
    url: assetUrl,
    originUrl: assetUrl,
    pathname: pathname,
    absolutePath: absolutePath || dir.from,
    relativePath: absolutePath ? path.relative(dir.from, absolutePath) : ".",
    search: parsedUrl.search || "",
    hash: parsedUrl.hash || ""
  };
};

var matchesFilter = function matchesFilter(asset, pattern) {
  var relativeToRoot = path.relative(process.cwd(), asset.absolutePath);

  if (typeof pattern == "string") {
    pattern = minimatch.filter(pattern);
    return pattern(relativeToRoot);
  }

  if (pattern instanceof RegExp) {
    return pattern.test(relativeToRoot);
  }

  if (pattern instanceof Function) {
    return pattern(asset);
  }

  return true;
},
    matchOption = function matchOption(asset, option) {
  var matched = matchesFilter(asset, option.filter);
  if (!matched) return false;
  return typeof option.url == "function" || !isUrlShouldBeIgnored(asset.url, option);
},
    isMultiOption = function isMultiOption(option) {
  return option.multi && typeof option.url == "function";
},
    matchOptions = function matchOptions(asset, options) {
  if (!options) return;

  if (Array.isArray(options)) {
    var optionIndex = options.findIndex(function (option) {
      return matchOption(asset, option);
    });
    if (optionIndex < 0) return;
    var matchedOption = options[optionIndex];
    if (optionIndex === options.length - 1) return matchedOption;
    var extendOptions = options.slice(optionIndex + 1).filter(function (option) {
      return (isMultiOption(matchedOption) || isMultiOption(option)) && matchOption(asset, option);
    });
    return extendOptions.length ? [matchedOption].concat(extendOptions) : matchedOption;
  }

  if (matchOption(asset, options)) return options;
};

var getFile = function getFile(asset, options, dir, warn) {
  var paths = options.basePath ? getPathByBasePath(options.basePath, dir.from, asset.pathname) : [asset.absolutePath],
      filePath = paths.find(fs__default.existsSync);

  if (!filePath) {
    warn("Can't read file '" + paths.join() + "', ignoring");
    return;
  }

  return {
    path: filePath,
    mimeType: mime.getType(filePath)
  };
};

var getHashName = function getHashName(file, options) {
  return assetHash.getHashedName(file.path, options);
};

function processCopy(asset, dir, options, decl, warn, result, addDependency) {
  return new Promise(function ($return, $error) {
    var file, assetRelativePath, pathObj, fileName, targetDir, newAssetBaseDir, newAssetPath, newRelativeAssetPath;

    if (!options.assetsPath && dir.from === dir.to) {
      warn("Option `to` of postcss is required, ignoring");
      return $return();
    }

    file = getFile(asset, options, dir, warn);
    if (!file) return $return();
    addDependency(file.path);
    return Promise.resolve(new Promise(function ($return, $error) {
      if (options.useHash) {
        return Promise.resolve(getHashName(file, options.hashOptions)).then($return, $error);
      }

      return $return(asset.relativePath);
    })).then(function ($await_4) {
      try {
        assetRelativePath = $await_4;

        if (options.useHash && options.keepName) {
          pathObj = path.parse(assetRelativePath);
          fileName = path.parse(asset.relativePath).name;
          pathObj.name = fileName + "_" + pathObj.name;
          delete pathObj.base;
          assetRelativePath = path.format(pathObj);
        }

        targetDir = getTargetDir(dir);
        newAssetBaseDir = getAssetsPath(targetDir, options.assetsPath);
        newAssetPath = path.join(newAssetBaseDir, assetRelativePath);
        newRelativeAssetPath = normalize(path.relative(targetDir, newAssetPath));
        return Promise.resolve(cpFile(file.path, newAssetPath, {
          overwrite: false
        })).then(function () {
          try {
            return $return("" + newRelativeAssetPath + asset.search + asset.hash);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

function getCustomProcessor(asset, dir, options) {
  return options.url.apply(null, arguments);
}

var readFileAsync = pify(fs.readFile),
    optimizedSvgEncode = function optimizedSvgEncode(svgContent) {
  var result = encodeURIComponent(svgContent).replace(/%3D/g, "=").replace(/%3A/g, ":").replace(/%2F/g, "/").replace(/%22/g, "'").replace(/%2C/g, ",").replace(/%3B/g, ";");
  return result.replace(/(%[0-9A-Z]{2})/g, function (matched, AZ) {
    return AZ.toLowerCase();
  });
};

var encodeFile = (function (file, encodeType, shouldOptimizeSvgEncode) {
  return new Promise(function ($return, $error) {
    var dataMime, contents, encodeFunc, content, encodedStr;
    dataMime = "data:" + file.mimeType;
    return Promise.resolve(readFileAsync(file.path)).then(function ($await_1) {
      try {
        contents = $await_1;

        if (encodeType === "base64") {
          return $return(dataMime + ";base64," + contents.toString("base64"));
        }

        encodeFunc = encodeType === "encodeURI" ? encodeURI : encodeURIComponent;
        content = contents.toString("utf8").replace(/\n+/g, "");
        encodedStr = shouldOptimizeSvgEncode && encodeType === "encodeURIComponent" ? optimizedSvgEncode(content) : encodeFunc(content);
        encodedStr = encodedStr.replace(/%20/g, " ").replace(/#/g, "%23");
        return $return(dataMime + "," + encodedStr);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
});

function processRebase (asset, dir) {
  var rebasedUrl = normalize(path.relative(dir.to, asset.absolutePath));
  return "" + rebasedUrl + asset.search + asset.hash;
}

function processFallback(originUrl, dir, options) {
  if (typeof options.fallback == "function") {
    return options.fallback.apply(null, arguments);
  }

  switch (options.fallback) {
    case "copy":
      return processCopy.apply(void 0, arguments);

    case "rebase":
      return processRebase.apply(void 0, arguments);

    default:
  }
}

function inlineType (asset, dir, options, decl, warn, result, addDependency) {
  var $args = arguments;
  return new Promise(function ($return, $error) {
    var file, maxSize, stats, isSvg, defaultEncodeType, encodeType, optimizeSvgEncode, encodedStr, resultValue;
    file = getFile(asset, options, dir, warn);
    if (!file) return $return();

    if (!file.mimeType) {
      warn("Unable to find asset mime-type for " + file.path);
      return $return();
    }

    maxSize = (options.maxSize || 0) * 1024;

    if (maxSize) {
      stats = fs__default.statSync(file.path);

      if (stats.size >= maxSize) {
        return $return(processFallback.apply(this, $args));
      }
    }

    isSvg = file.mimeType === "image/svg+xml";
    defaultEncodeType = isSvg ? "encodeURIComponent" : "base64";
    encodeType = options.encodeType || defaultEncodeType;

    if (isSvg && asset.hash && !options.ignoreFragmentWarning) {
      warn("Image type is svg and link contains #. PostCSS Smart Asset can't handle SVG fragments. SVG file fully inlined. " + file.path);
    }

    addDependency(file.path);
    optimizeSvgEncode = isSvg && options.optimizeSvgEncode;
    return Promise.resolve(encodeFile(file, encodeType, optimizeSvgEncode)).then(function ($await_1) {
      try {
        encodedStr = $await_1;
        resultValue = options.includeUriFragment && asset.hash ? encodedStr + asset.hash : encodedStr;
        return $return(isSvg && encodeType !== "base64" ? "\"" + resultValue + "\"" : resultValue);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  }.bind(this));
}

var typeMap = {
  copy: processCopy,
  custom: getCustomProcessor,
  inline: inlineType,
  rebase: processRebase
},
    PROCESS_TYPES = ["rebase", "inline", "copy", "custom"],
    getUrlProcessorType = function getUrlProcessorType(optionUrl) {
  return typeof optionUrl == "function" ? "custom" : optionUrl || "rebase";
};

function getUrlProcessor(optionUrl) {
  var mode = getUrlProcessorType(optionUrl);

  if (PROCESS_TYPES.indexOf(mode) === -1) {
    throw new Error("Unknown mode for postcss-url: " + mode);
  }

  return typeMap[mode];
}

var wrapUrlProcessor = function wrapUrlProcessor(urlProcessor, result, decl) {
  var warn = function warn(message) {
    return decl.warn(result, message);
  },
      addDependency = function addDependency(file) {
    return result.messages.push({
      type: "dependency",
      file: file,
      parent: getPathDeclFile(decl)
    });
  };

  return function (asset, dir, option) {
    return urlProcessor(asset, dir, option, decl, warn, result, addDependency);
  };
};

var replaceUrl = function replaceUrl(url$$1, dir, options, result, decl) {
  var asset = prepareAsset(url$$1, dir, decl),
      matchedOptions = matchOptions(asset, options);
  if (!matchedOptions) return;

  var process = function process(option) {
    var wrappedUrlProcessor = wrapUrlProcessor(getUrlProcessor(option.url), result, decl);
    return wrappedUrlProcessor(asset, dir, option);
  };

  if (Array.isArray(matchedOptions)) {
    matchedOptions.forEach(function (option) {
      return asset.url = process(option);
    });
  } else {
    asset.url = process(matchedOptions);
  }

  return asset.url;
};
var WITH_QUOTES = /^['"]/;

function buildResult(newUrl, matched, before, after) {
  if (!newUrl) return matched;

  if (WITH_QUOTES.test(newUrl) && WITH_QUOTES.test(after)) {
    before = before.slice(0, -1);
    after = after.slice(1);
  }

  return "" + before + newUrl + after;
}

var declProcessor = function declProcessor(from, to, options, result, decl) {
  var dir = {
    from: from,
    to: to,
    file: getDirDeclFile(decl)
  },
      pattern = /(url\(\s*['"]?)([^"')]+)(["']?\s*\))/g;

  var matches = decl.value.match(pattern);

  if (!matches) {
    return;
  }

  return Promise.all(matches.map(function (singleMatch) {
    var _$exec = /(url\(\s*['"]?)([^"')]+)(["']?\s*\))/.exec(singleMatch),
        matched = _$exec[0],
        before = _$exec[1],
        url$$1 = _$exec[2],
        after = _$exec[3],
        replacement = replaceUrl(url$$1, dir, options, result, decl);

    if (replacement) {
      if (replacement.then) {
        return replacement.then(function (resolved) {
          return buildResult(resolved, singleMatch, before, after);
        });
      } else {
        return buildResult(replacement, singleMatch, before, after);
      }
    } else {
      return null;
    }
  })).then(function (values) {
    decl.value = decl.value.replace(pattern, function (match) {
      var replacement = values.shift();
      return replacement == null ? match : replacement;
    });
  });
};

var index = postcss.plugin("postcss-smart-asset", function (options) {
  if (options === void 0) {
    options = {};
  }

  return function (root, result) {
    var opts = result.opts,
        from = opts.from ? path.dirname(opts.from) : ".",
        to = opts.to ? path.dirname(opts.to) : from,
        promises = [];
    root.walkDecls(function (decl) {
      var waiter = declProcessor(from, to, options, result, decl);

      if (waiter && waiter.then) {
        promises.push(waiter);
      }
    });
    return Promise.all(promises);
  };
});

module.exports = index;
//# sourceMappingURL=index.cjs.js.map
