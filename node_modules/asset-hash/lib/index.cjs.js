/*! asset-hash v2.2.5 by Sebastian Werner <s.werner@sebastian-software.de> */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('core-js/modules/es6.promise');
require('core-js/modules/es6.regexp.to-string');
require('core-js/modules/es6.date.to-string');
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var BigInt = _interopDefault(require('big.js'));
var metrohash = require('metrohash');
var XXHash32 = require('xxhash');
var XXHash32__default = _interopDefault(XXHash32);

var DEFAULT_HASH = "metrohash128",
    DEFAULT_ENCODING = "base52",
    DEFAULT_MAX_LENGTH = 8,
    XXHASH_CONSTRUCT = 0xcafebabe,
    baseEncodeTables = {
  26: "abcdefghijklmnopqrstuvwxyz",
  32: "123456789abcdefghjkmnpqrstuvwxyz",
  36: "0123456789abcdefghijklmnopqrstuvwxyz",
  49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
  58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
  64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
};
function baseEncode(buffer, base) {
  var baseNum = typeof base == "number" ? base : /[0-9]+/.exec(base)[0],
      encodeTable = baseEncodeTables[baseNum];

  if (!encodeTable) {
    throw new Error("Unknown base encoding " + base + "!");
  }

  var length = buffer.length;
  BigInt.DP = 0;
  BigInt.RM = 0;

  for (var current = new BigInt(0), i = length - 1; i >= 0; i--) {
    current = current.times(256).plus(buffer[i]);
  }

  var output = "";

  while (current.gt(0)) {
    output = encodeTable[current.mod(baseNum)] + output;
    current = current.div(baseNum);
  }

  BigInt.DP = 20;
  BigInt.RM = 1;
  return output;
}

function computeDigest(bufferOrString, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      encoding = _ref.encoding,
      maxLength = _ref.maxLength,
      output = "",
      isString = typeof bufferOrString == "string";

  if (isString && encoding === "hex") {
    output = bufferOrString;
  } else {
    var buffer = isString ? Buffer.from(bufferOrString, "hex") : bufferOrString;

    if (encoding === "hex" || encoding === "base64" || encoding === "utf8") {
      output = buffer.toString(encoding);
    } else {
      output = baseEncode(buffer, encoding);
    }
  }

  return maxLength == null || output.length <= maxLength ? output : output.slice(0, maxLength);
}

var Hasher =
/*#__PURE__*/
function () {
  function Hasher(options) {
    if (options === void 0) {
      options = {};
    }

    this._hasher = createHasher(options.hash || DEFAULT_HASH);
    this._encoding = options.encoding || DEFAULT_ENCODING;
    this._maxLength = options.maxLength || DEFAULT_MAX_LENGTH;
  }

  var _proto = Hasher.prototype;

  _proto.update = function update(data) {
    var buffer = data instanceof Buffer ? data : Buffer.from(data.toString(), "utf-8");
    return this._hasher.update(buffer);
  };

  _proto.digest = function digest(encoding, maxLength) {
    return computeDigest(this._hasher.digest("buffer"), {
      encoding: encoding || this._encoding,
      maxLength: maxLength || this._maxLength
    });
  };

  return Hasher;
}();
function createHasher(hash) {
  var hasher;

  if (hash === "xxhash32") {
    hasher = new XXHash32__default(XXHASH_CONSTRUCT);
  } else if (hash === "xxhash64") {
    hasher = new XXHash32.XXHash64(XXHASH_CONSTRUCT);
  } else if (hash === "metrohash64") {
    hasher = new metrohash.MetroHash64();
  } else if (hash === "metrohash128") {
    hasher = new metrohash.MetroHash128();
  } else {
    hasher = crypto.createHash(hash);
  }

  return hasher;
}
function getHash(fileName, options) {
  var _ref2 = options || {},
      hash = _ref2.hash,
      encoding = _ref2.encoding,
      maxLength = _ref2.maxLength;

  return new Promise(function (resolve, reject) {
    try {
      var hasher = createHasher(hash || DEFAULT_HASH);
      fs.createReadStream(fileName).on("data", function (data) {
        hasher.update(data);
      }).on("error", function (error) {
        reject(error);
      }).on("end", function () {
        try {
          var digest = computeDigest(hasher.digest("buffer"), {
            encoding: encoding || DEFAULT_ENCODING,
            maxLength: maxLength || DEFAULT_MAX_LENGTH
          });
          resolve(digest);
        } catch (error) {
          reject(error);
        }
      });
    } catch (error) {
      reject(error);
    }
  });
}
function getHashedName(fileName, options) {
  return new Promise(function ($return, $error) {
    var hashed, extension;
    return Promise.resolve(getHash(fileName, options)).then(function ($await_3) {
      try {
        hashed = $await_3;
        extension = path.extname(fileName);
        return $return(hashed + extension);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

exports.baseEncode = baseEncode;
exports.Hasher = Hasher;
exports.createHasher = createHasher;
exports.getHash = getHash;
exports.getHashedName = getHashedName;
//# sourceMappingURL=index.cjs.js.map
