/*! rollup-plugin-rebase v2.0.4 by Sebastian Werner <s.werner@sebastian-software.de> */
import 'core-js/modules/es6.promise';
import 'core-js/modules/es6.string.iterator';
import 'core-js/modules/es6.regexp.replace';
import 'core-js/modules/es6.array.map';
import 'core-js/modules/web.dom.iterable';
import 'core-js/modules/es6.array.iterator';
import 'core-js/modules/es6.object.keys';
import 'core-js/modules/es6.regexp.to-string';
import 'core-js/modules/es6.date.to-string';
import path from 'path';
import fs from 'fs-extra';
import postcss from 'postcss';
import postcssImport from 'postcss-import';
import postcssSass from 'postcss-sass';
import postcssScss from 'postcss-scss';
import postcssSmartAsset from 'postcss-smart-asset';
import postcssSugarSS from 'sugarss';
import { createFilter } from 'rollup-pluginutils';
import { getHash } from 'asset-hash';

var defaultExclude = [/\.json$/, /\.mjs$/, /\.js$/, /\.jsx$/, /\.es$/, /\.esx$/, /\.ts$/, /\.tsx$/, /\.vue$/],
    styleParser = {
  ".pcss": null,
  ".css": null,
  ".sss": postcssSugarSS,
  ".scss": postcssScss,
  ".sass": postcssSass
};

function getPostCssPlugins(keepName) {
  return [postcssImport(), postcssSmartAsset({
    url: "copy",
    useHash: true,
    keepName: keepName
  })];
}

function processStyle(id, fileDest, keepName) {
  return new Promise(function ($return, $error) {
    var content, parser, processor, text, result;
    return Promise.resolve(fs.readFile(id)).then(function ($await_3) {
      try {
        content = $await_3;
        parser = styleParser[path.extname(id)];
        processor = postcss(getPostCssPlugins(keepName));
        text = content.toString();
        return Promise.resolve(processor.process(text, {
          from: id,
          to: fileDest,
          extensions: Object.keys(styleParser),
          map: {
            inline: false
          },
          parser: parser
        })).then(function ($await_4) {
          try {
            result = $await_4;
            return Promise.resolve(fs.outputFile(fileDest, result.css)).then(function () {
              try {
                return Promise.resolve(fs.outputFile(fileDest + ".map", result.map)).then(function () {
                  try {
                    return $return();
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }, $error);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }, $error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

function rebase(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      include = _options.include,
      _options$exclude = _options.exclude,
      exclude = _options$exclude === void 0 ? defaultExclude : _options$exclude,
      _options$verbose = _options.verbose,
      verbose = _options$verbose === void 0 ? false : _options$verbose,
      _options$keepName = _options.keepName,
      keepName = _options$keepName === void 0 ? false : _options$keepName,
      _options$folder = _options.folder,
      folder = _options$folder === void 0 ? "" : _options$folder,
      filter = createFilter(include, exclude),
      wrappers = {},
      assets = {},
      files = {};
  return {
    name: "rollup-plugin-rebase",
    resolveId: function resolveId(importee, importer) {
      return new Promise(function ($return, $error) {
        var fileExt, fileSource, fileName, fileHash, fileTarget, assetId, resolvedId;

        if (!filter(importee)) {
          return $return(null);
        }

        if (!importer) {
          return $return(null);
        }

        if (assets[importee] != null) {
          return $return(false);
        }

        fileExt = path.extname(importee);

        if (fileExt === "") {
          return $return(null);
        }

        fileSource = path.resolve(path.dirname(importer), importee);
        fileName = path.basename(importee, fileExt);
        return Promise.resolve(getHash(fileSource)).then(function ($await_7) {
          try {
            fileHash = $await_7;
            fileTarget = keepName ? fileName + "_" + fileHash + fileExt : "" + fileHash + fileExt;
            files[fileSource] = path.join(folder, fileTarget);
            assetId = path.join(path.dirname(importer), folder, fileTarget).replace(/\\/g, "/");
            resolvedId = assetId + ".js";
            assets[assetId] = true;
            wrappers[resolvedId] = assetId;
            return $return(resolvedId);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      });
    },
    load: function load(id) {
      if (wrappers[id] != null) {
        var importee = wrappers[id];
        return "export { default } from \"" + importee + "\";";
      }

      return null;
    },
    generateBundle: function generateBundle(_ref) {
      return new Promise(function ($return, $error) {
        var file, outputFolder;
        file = _ref.file;
        outputFolder = path.dirname(file);

        var $Try_1_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        },
            $Try_1_Catch = function (error) {
          try {
            throw new Error("Error while copying files:", error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(Promise.all(Object.keys(files).map(function (fileSource) {
            return new Promise(function ($return, $error) {
              var fileDest, fileExt;
              fileDest = path.join(outputFolder, files[fileSource]);
              fileExt = path.extname(fileSource);

              if (fileExt in styleParser) {
                if (verbose) {
                  console.log("Processing " + fileSource + " => " + fileDest + "...");
                }

                return Promise.resolve(processStyle(fileSource, fileDest, keepName)).then(function () {
                  try {
                    return $If_2.call(this);
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              } else {
                if (verbose) {
                  console.log("Copying " + fileSource + " => " + fileDest + "...");
                }

                return Promise.resolve(fs.copy(fileSource, fileDest)).then(function () {
                  try {
                    return $If_2.call(this);
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              }

              function $If_2() {
                return $return();
              }
            });
          }))).then(function () {
            try {
              return $Try_1_Post();
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }, $Try_1_Catch);
        } catch (error) {
          $Try_1_Catch(error);
        }
      });
    }
  };
}

export default rebase;
//# sourceMappingURL=index.esm.js.map
